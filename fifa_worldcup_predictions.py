# -*- coding: utf-8 -*-
"""FIFA WorldCup - Predictions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vJ5RNMS3XYb7pdEumFQQlxyDXeQtvWM4

# Folpetti - Predição Jogos da Copa do Mundo de Futebol

Aplicação de Machine Learning para predição do resultado dos jogos em 2022

**CR**oss **I**ndustry **S**tandard **P**rocess for **D**ata **M**ining (CRISP-DM) 

<img width="300px" style="text-align:center;" src="https://upload.wikimedia.org/wikipedia/commons/b/b9/CRISP-DM_Process_Diagram.png" />

## Objetivo (Entendendo do Negócio)

Devemos gerar o resultado dos jogos com a quantidade de gols para os dois times, acreditando que não faz sentido gerar a predição de dois valores indepentendes vamos adotar a classificação de eventos

> **Classificação**: Aplicação supervisionada de Machine Learning para encaixar o registro em um grupo, dentre os pré-definidos


Com as seguintes regras:

- Não pode ser usado nenhum tipo de enriquecimento, importação de dados externos ou introdução manual de dados;
- Replicabilidade é essencial, como é uma atividade que deve ser validada no seu processo e aplicabilidade, os valores aletórios devem ser controlados para sempre ter os mesmos resultados.

## Coleta, Compreensão e Preparação

Usando somentes base dados presentes no repositório [Eduardo Ruela - Paul Octopus 2022](https://github.com/edruela/paul-octopus-2022)
"""

# Importação da biblioteca para lidar com os dados
import pandas as pd
# Importação de biblioteca matemática
import numpy as np

# Definição do caminho padrão das informações
path_source = './datasets/'

# Definição de função para rodar por linha de comando
display = print

"""### Remover os outliers dos valores 

Usando o critério do 150% do IQR (Q3 - Q1) 
"""

# Definição da função para remover outliers
def remove_outlier(df_in, col_name):
    # Pegar limite primeiro e terceiro quadrante
    q1 = df_in[col_name].quantile(0.25)
    q3 = df_in[col_name].quantile(0.75)

    # Alcance do primeiro e terceiro quadrante
    iqr = q3 - q1

    # Definição de limites 
    limite_inferior = q1 - 1.5 * iqr
    limite_superior = q3 + 1.5 * iqr

    # Realizar a filtragem dos outliers
    list_remove = (df_in[col_name] < limite_inferior) | (df_in[col_name] > limite_superior)
    print(f"Campo {col_name} limites {limite_inferior:.3f} a {limite_superior:.3f} contagem {len(df_in[list_remove].index)}")

    return df_in[~list_remove]

"""### Histórico de resultados (historical-results.csv)

Uma listagem dos resultados dos jogos de outros anos com dados
"""

# Leitura do "Histórico de resultados"
df_results = pd.read_csv(path_source + 'historical-results.csv')

# Visualização dos dados importados
df_results.head()

"""Informações da fonte de dados"""

df_results.info()

# Remover valores nulos na coluna de home score
df_results = df_results[df_results.home_score.notna()]

# Remover outliers da pontuação do time da casa
df_results = remove_outlier(df_results, 'home_score')
# Remover outliers da pontuação do time da visitante
df_results = remove_outlier(df_results, 'away_score')

print('\n')
df_results.info()

"""Para poder absorver as informações de data convertemos em formato de data e separamos as informações de ano, mês, dia da semana e semana do ano"""

# Converter texto para date em pandas
df_results['datetime'] = pd.to_datetime(df_results.date, format='%Y-%m-%d')

# Extrair trechos da data
def get_dates(datasource):
  datasource['dayofweek'] = pd.DatetimeIndex(datasource.datetime).dayofweek.astype(str)
  datasource['weekofyear'] = datasource.datetime.dt.isocalendar().week
  datasource['month'] = pd.DatetimeIndex(datasource.datetime).month
  datasource['year'] = pd.DatetimeIndex(datasource.datetime).year

  return datasource

# Aplicação da função
get_dates(df_results)

# Visualizar os campos
df_results[[
      'date', 
      'datetime', 
      'dayofweek', 
      'weekofyear', 
      'month', 
      'year'
    ]].head()

"""Gerar fonte de dados com os nomes dos países para comparar com os outros arquivos"""

# Juntas as duas listas
results_countries = df_results.home_team.to_list() + df_results.away_team.to_list()
# Transformar a lista em DataFrame
df_results_countries = pd.DataFrame(results_countries, columns = ['country']).sort_values('country')
# Separar os valores únicos 
results_countries = df_results_countries.country.unique()

# Transformar a lista única em DataFrame
df_results_countries = pd.DataFrame(results_countries, columns = ['country']).sort_values('country')
df_results_countries

"""Vamos tirar umas métricas desses resultados como porcentagem de vitórias e empates"""

# Apurar o vencedor das disputas
def getwinner(row):
  if row.home_score > row.away_score: 
    return row.home_team 
  if row.home_score < row.away_score: 
    return row.away_team
  return 'draw'

# Selecionar o vencedor do evento
df_results['id'] = df_results.index
df_results['winner'] =  df_results.apply(getwinner, axis=1)

# Totalizar o número de vitórias por seleção
winner_count = df_results.groupby('winner').id.count().rename("count_winner").reset_index(name='count_winner').rename(columns={"winner":"country"})
winner_count.info()
print('\n')

# Totalizar o número de vitórias por seleção em jogos da Copa
fifa_winner_count = df_results[df_results.tournament == "FIFA World Cup"].groupby('winner').id.count().rename("count_fifa_winner").reset_index(name='count_fifa_winner').rename(columns={"winner":"country"})
fifa_winner_count.info()

# Contagem da presença das seleções
home_count = df_results.groupby('home_team').id.count().rename("home_count").reset_index(name="home_count").rename(columns={"home_team":"country"})
away_count = df_results.groupby('away_team').id.count().rename("away_count").reset_index(name="away_count").rename(columns={"away_team":"country"})

# Contagem da presença das seleções nas Copas do Mundo
home_count_fifa = df_results[df_results.tournament == "FIFA World Cup"].groupby('home_team').id.count().rename("home_count_fifa").reset_index(name="home_count_fifa").rename(columns={"home_team":"country"})
away_count_fifa = df_results[df_results.tournament == "FIFA World Cup"].groupby('away_team').id.count().rename("away_count_fifa").reset_index(name="away_count_fifa").rename(columns={"away_team":"country"})

# Juntar a contagem de participaão em jogos e jogos da Copa
country_summary = pd.merge(home_count, away_count, how='outer',
                           left_on=['country'],
                           right_on=['country'])
country_summary = pd.merge(country_summary, home_count_fifa, how='left',
                           left_on=['country'],
                           right_on=['country'])
country_summary = pd.merge(country_summary, away_count_fifa, how='left',
                           left_on=['country'],
                           right_on=['country'])

# Preencher as lacunas com zero e totalizar os valores 
country_summary.loc[country_summary.home_count.isna(), ['home_count']] = 0
country_summary.loc[country_summary.away_count.isna(), ['away_count']] = 0
country_summary['total'] = country_summary.home_count + country_summary.away_count

# Preencher as lacunas com zero com resultados FIFA e totalizar os valores
country_summary.loc[country_summary.home_count_fifa.isna(), ['home_count_fifa']] = 0
country_summary.loc[country_summary.away_count_fifa.isna(), ['away_count_fifa']] = 0
country_summary['total_fifa'] = country_summary.home_count_fifa + country_summary.away_count_fifa

country_summary.info()

# Calcular a mediana da pontuação por países
home_score_by_country = df_results[['home_team', 'home_score']].rename(columns={'home_team': 'country', 'home_score': 'score'})
away_score_by_country = df_results[['away_team', 'away_score']].rename(columns={'away_team': 'country', 'away_score': 'score'})

scores_by_country = pd.concat([home_score_by_country, away_score_by_country]).groupby('country').score.median().rename('median_score')
display(scores_by_country.head())

# Calcular a mediana da pontuação por países na Copa do Mundo
home_score_fifa = df_results[df_results.tournament == "FIFA World Cup"][['home_team', 'home_score']].rename(columns={'home_team': 'country', 'home_score': 'score'})
away_score_fifa = df_results[df_results.tournament == "FIFA World Cup"][['away_team', 'away_score']].rename(columns={'away_team': 'country', 'away_score': 'score'})

scores_by_country_fifa = pd.concat([home_score_fifa, away_score_fifa]).groupby('country').score.median().rename('median_fifa_score')
display(scores_by_country_fifa.head())

# Juntar com a mediana das pontuações 
country_summary = pd.merge(country_summary, scores_by_country, how='left', left_on=['country'], right_on=['country'])
country_summary = pd.merge(country_summary, scores_by_country_fifa, how='left', left_on=['country'], right_on=['country'])

# Preencher as lacunas com zero
country_summary.loc[country_summary.median_score.isna(), ['median_score']] = 0
country_summary.loc[country_summary.median_fifa_score.isna(), ['median_fifa_score']] = 0

country_summary.head()

#
country_summary = pd.merge(country_summary, winner_count, how='left', left_on=['country'], right_on=['country'])
country_summary.loc[country_summary.count_winner.isna(), ['count_winner']] = 0

#
country_summary = pd.merge(country_summary, fifa_winner_count, how='left', left_on=['country'], right_on=['country'])
country_summary.loc[country_summary.count_fifa_winner.isna(), ['count_fifa_winner']] = 0

# Visualização da fonte de dados nesse momento
print(country_summary.info())
display(country_summary.head())

country_summary['ratio_win'] = country_summary.count_winner / country_summary.total
country_summary['ratio_win_fifa'] = country_summary.count_fifa_winner / country_summary.total_fifa

country_summary.loc[country_summary.ratio_win_fifa.isna(), ['ratio_win_fifa']] = 0
country_summary.loc[country_summary.ratio_win_fifa.isna(), ['ratio_win_fifa']] = 0

country_summary = country_summary[['country', 'ratio_win', 'ratio_win_fifa', 'median_score', 'median_fifa_score']] 

# Visualização da fonte de dados estruturado
print(country_summary.info())
display(country_summary.head())

# Buscar os valores do home e away teams
home_country_summary = country_summary.rename(columns=
  {'country':'home_team', 'ratio_win':'home_ratio_win', 'ratio_win_fifa':'home_ratio_win_fifa', 'median_score': 'home_median_score', 'median_fifa_score': 'home_median_fifa_score'})
away_country_summary = country_summary.rename(columns=
  {'country':'away_team', 'ratio_win':'away_ratio_win', 'ratio_win_fifa':'away_ratio_win_fifa', 'median_score': 'away_median_score', 'median_fifa_score': 'away_median_fifa_score'})

# Resumir os valores médios
results_summary = country_summary.median(numeric_only=True)
results_summary

'''
#
home_score = df_results[['home_team', 'home_score']].rename(columns={'home_team': 'country', 'home_score': 'score'})
away_score = df_results[['away_team', 'away_score']].rename(columns={'away_team': 'country', 'away_score': 'score'})
scores = pd.concat([home_score, away_score])

#
home_score_fifa = df_results[df_results.tournament == 'FIFA World Cup'][['home_team', 'home_score']].rename(columns={'home_team': 'country', 'home_score': 'score'})
away_score_fifa = df_results[df_results.tournament == 'FIFA World Cup'][['away_team', 'away_score']].rename(columns={'away_team': 'country', 'away_score': 'score'})
scores_fifa = pd.concat([home_score_fifa, away_score_fifa])
'''

def get_country_summary(datasource):
  # Unir o "Histórico de resultados" com "Resumo dos resultados"
  result = pd.merge(datasource, home_country_summary, how='left', 
                    left_on=['home_team'], 
                    right_on=['home_team'])
  result = pd.merge(result, away_country_summary, how='left', 
                    left_on=['away_team'], 
                    right_on=['away_team'])

  # Inclusão de valores sumarizados dos resultados
  result['summary_ratio_win'] = results_summary.ratio_win
  result['summary_ratio_win_fifa'] = results_summary.ratio_win_fifa
  result['summary_median_score'] = results_summary.median_score
  result['summary_median_fifa_score'] = results_summary.median_fifa_score

  '''
  # Armazenar percentils para scores geral
  result['summary_min_score'] = scores.min().score
  result['summary_qt1_score'] = scores.quantile(.25).score
  result['summary_qt3_score'] = scores.quantile(.75).score
  result['summary_max_score'] = scores.max().score

  # Armazer percentils para scores na FIFA
  result['summary_min_score_fifa'] = scores_fifa.min().score
  result['summary_qt1_score_fifa'] = scores_fifa.quantile(.25).score
  result['summary_qt3_score_fifa'] = scores_fifa.quantile(.75).score  
  result['summary_max_score_fifa'] = scores_fifa.max().score
  '''

  return result

# Chamada da função de sumarização
df_results = get_country_summary(df_results)

# Preparar a fonte de dados eliminando colunas não usadas
df_results = df_results.drop(columns=['winner', 'id'])

# Visualizar resultado
df_results.head()

"""### Jogos por resolvidos por pênaltis (shootouts.csv)

Listagem dos jogos resolvidos nos pênaltis com a indicação do vencedor
"""

# Leitura dos jogos por "Resolvidos por pênaltis"
df_shootouts = pd.read_csv(path_source + 'shootouts.csv')

# Acesso da identificação do index
df_shootouts['id'] = df_shootouts.index

# Visualização dos dados importados
df_shootouts.head()

# Contagem de vitórias dos times
count_winner = df_shootouts.groupby(['winner']).id.count().rename('count_winner')
# Converter para data frame
country_shootouts = count_winner.reset_index(name='count_winner')
# Renomear coluna para 
country_shootouts = country_shootouts.rename(columns={"winner": "country"})

# Contagem de seleções em home
home_count = df_shootouts.groupby(['home_team']).id.count().rename('home_count')
# Mergiar com os resultados de vitória
country_shootouts = pd.merge(country_shootouts, home_count,
                              how='left',
                              left_on=['country'],
                              right_on=['home_team'])

# Contagem de seleções em away
away_count = df_shootouts.groupby(['away_team']).id.count().rename('away_count')
# Mergiar com os resultados de vitória
country_shootouts = pd.merge(country_shootouts, away_count,
                              how='left',
                              left_on=['country'],
                              right_on=['away_team'])

# Preencher as lacunas com zero
country_shootouts.loc[country_shootouts.home_count.isna(), ['home_count']] = 0
country_shootouts.loc[country_shootouts.away_count.isna(), ['away_count']] = 0

# Calcular a porcentagem de vitórias
country_shootouts['ratio_win_shootouts'] = country_shootouts.apply(lambda row: row.count_winner / (row.home_count + row.away_count), axis=1)

# Preparar a fonte de dados eliminando colunas não usadas
country_shootouts = country_shootouts.drop(columns=['count_winner', 'home_count', 'away_count'])

country_shootouts.head()

def get_count_shootouts(datasource):
  ratio_win_shootouts_home = country_shootouts.rename(columns={"country":"home_team", "ratio_win_shootouts":"home_ratio_win_shootouts"})

  # Unir o "Histórico de resultados" com "Resolvidos por pênaltis"
  result = pd.merge(datasource, ratio_win_shootouts_home, how='left',
                                left_on=['home_team'],
                                right_on=['home_team'])
  
  away_ratio_win_shootouts = country_shootouts.rename(columns={"country": "away_team", "ratio_win_shootouts":"away_ratio_win_shootouts"})

  # Unir o "Histórico de resultados" com "Resolvidos por pênaltis"
  result = pd.merge(result, away_ratio_win_shootouts, how='left',
                                left_on=['away_team'],
                                right_on=['away_team'])
  
  # Completar valores nulos
  result.loc[result.home_ratio_win_shootouts.isna(), ['home_ratio_win_shootouts']] = 0
  result.loc[result.away_ratio_win_shootouts.isna(), ['away_ratio_win_shootouts']] = 0

  return result
  
# Executação da junção e apresentação do resultado
df_results = get_count_shootouts(df_results)
df_results.head()

"""### Sumarização do resultados de jogos por seleções (historical_win-loose-draw_ratios.csv)

Listagem da relação entre times com a contagem dos jogos, porcentagem de vitórias, porcentagem de derrotas e porcentagem de empates
"""

# Leitura da "Sumarização do resultados de jogos por seleções"
df_ratios = pd.read_csv(path_source + 'historical_win-loose-draw_ratios.csv')

# Visualização dos dados importados
df_ratios.head()

df_ratios.info()

"""Geração das lista com os nomes dos países diferentes usados para comparação com os resultados

"""

ratios_countries = df_ratios.country1.to_list() + df_ratios.country2.to_list()
df_ratios_countries = pd.DataFrame(ratios_countries, columns = ['country'])
ratios_countries = df_ratios_countries.sort_values('country').country.unique()
ratios_countries

"""Comparação da lista do sumário com a fonte de dados dos resultados, para validar se a lista é a mesma"""

df_results_countries[df_results_countries.country.isin(ratios_countries)].country.unique()

"""#### Organização dos campos"""

# Renomear as colunas para unir com resultados
df_ratios = df_ratios.rename(columns={
    'country1': 'home_team',
    'country2': 'away_team',
    'games': 'home_games',
    'wins': 'home_wins',
    'looses': 'home_looses',
    'draws': 'home_draws'
})

# Replicar para os times visitantes
df_ratios['away_games'] = df_ratios.home_games
df_ratios['away_wins'] = df_ratios.home_wins
df_ratios['away_looses'] = df_ratios.home_looses
df_ratios['away_draws'] = df_ratios.home_draws

# Definição de campos ratio
home_fields_ratios = ['home_games', 'home_wins', 'home_looses', 'home_draws']
away_fields_ratios = ['away_games', 'away_wins', 'away_looses', 'away_draws']

# Remover os outliers da home
for col_name in home_fields_ratios:
  df_ratios = remove_outlier(df_ratios, col_name)

"""#### Unificação dos dados da sumarização """

# Mediana dos valores por paises da sumárização
median_by_country = df_ratios.groupby('home_team').median()

# Mediana dos valores por paises da sumárização
median_general = df_ratios.median(numeric_only=True)

def get_ratios(datasource):
  # Unir o "Histórico de resultados" com 
  # "Sumarização do resultados de jogos por seleções"
  result = pd.merge(datasource, df_ratios, how='left', left_on=['home_team', 'away_team'], right_on=['home_team', 'away_team'])
  
  # Completar os campos vazios com a mediana do país com os outros times
  for index, row in median_by_country.iterrows():
    for field in home_fields_ratios:
      result.loc[(result.home_team == index) & result[field].isna(), [field]] = row[field]
    for field in away_fields_ratios:
      result.loc[(result.away_team == index) & result[field].isna(), [field]] = row[field]

  # Completar os campos vazios 
  # com a mediana do país com os outros times
  for field in home_fields_ratios:
    result.loc[result[field].isna(), [field]] = median_general[field]
  for field in away_fields_ratios:
    result.loc[result[field].isna(), [field]] = median_general[field]    

  return result

df_results = get_ratios(df_results)
df_results.head()

"""### Classificação das seleções (ranking.csv)



"""

# Leitura da "Classificação das seleções por períodos"
df_ranking = pd.read_csv(path_source + 'ranking.csv')

# Apresentação dos dados da "Classificação das seleções por períodos"
df_ranking.head()

df_ranking.nunique()

ranking_countries = np.array(df_ranking.sort_values('country_full').country_full.unique()).tolist()

print("Valores em resultado e não no ranking")
print(df_results_countries[~df_results_countries.country.isin(ranking_countries)].country.unique())

print("\nValores em ranking e não no resultado")
print(df_ranking[~df_ranking.country_full.isin(results_countries)].sort_values('country_full').country_full.unique())

# Relação dos nomes dos países
name_countries_by_usa = {
      "Cabo Verde": "Cape Verde",
      "Cape Verde Islands": "Cape Verde",
      'Congo DR': 'DR Congo',
      "Curacao": "Curaçao",
      "Netherlands Antilles": "Curaçao",
      "German DR": "Germany", 
      'USA': 'United States',
      'Korea DPR': 'North Korea',
      'Korea Republic': 'South Korea',
      'IR Iran': 'Iran',
      "Swaziland": "Eswatini",
      'Chinese Taipei': 'Taiwan',
      "Côte d'Ivoire": 'Ivory Coast',
      "US Virgin Islands": "United States Virgin Islands",
      "Saint Vincent and the Grenadines": "Saint Vincent and the Grenadines",
      "St. Vincent and the Grenadines": "Saint Vincent and the Grenadines",
      "St. Vincent / Grenadines": "Saint Vincent and the Grenadines",
      "St. Kitts and Nevis": "Saint Kitts and Nevis",
      "St. Lucia": "Saint Lucia",
      "São Tomé e Príncipe": "São Tomé and Príncipe",
      "Sao Tome e Principe": "São Tomé and Príncipe",
      "FYR Macedonia": "North Macedonia",
      "Türkiye": "Turkey",
      "Kyrgyz Republic": "Kyrgyzstan"
    }

# Renomear os valores na coluna 
df_ranking.country_full = df_ranking.country_full.replace(name_countries_by_usa)

# Apresentar os nomes nos ranking sem relação com a lista de resultados
df_ranking[~df_ranking.country_full.isin(results_countries)].sort_values('country_full').country_full.unique()

df_ranking[df_ranking.country_full == "Germany"].head()

# Conversão da data do rank em formato de data
df_ranking['datetime'] = pd.to_datetime(df_ranking.rank_date, format='%Y-%m-%d')
# Obter os anos de ranking
df_ranking['year'] = pd.DatetimeIndex(df_ranking.datetime).year

# Buscar a última pontuação 
last_ranking = df_ranking.sort_values('year', ascending=False).groupby('country_full').head(1)

# Visualizar resumo dos rankings
last_ranking.info()

# Renomear o resultado para o time da casa
home_last_ranking = last_ranking[['country_full', 'confederation', 'year', 'rank', 'total_points']].rename(columns={'country_full':'home_team', 'confederation': 'home_confederation', 'rank':'home_last_rank', 'total_points':'home_last_points'})
# Renomear o resultado para o time de fora
away_last_ranking = last_ranking[['country_full', 'confederation', 'year', 'rank', 'total_points']].rename(columns={'country_full':'away_team', 'confederation': 'away_confederation', 'rank':'away_last_rank', 'total_points':'away_last_points'})

def get_ranking(datasource):
  # Unir com última pontuação do time da casa
  result = pd.merge(datasource, home_last_ranking, how='left',
                            left_on=['home_team', 'year'],
                            right_on=['home_team', 'year'])
  # Unir com última pontuação do time de fora
  result = pd.merge(result, away_last_ranking, how='left',
                            left_on=['away_team', 'year'],
                            right_on=['away_team', 'year'])

  # Completar mediana dos últimos ranks quanto nulos
  result.loc[result.home_last_rank.isna(), ['home_last_rank']] = last_ranking['rank'].median()
  result.loc[result.away_last_rank.isna(), ['away_last_rank']] = last_ranking['rank'].median()
  # Completar mediana dos últimos valores quanto nulos
  result.loc[result.home_last_points.isna(), ['home_last_points']] = last_ranking.total_points.median()
  result.loc[result.away_last_points.isna(), ['away_last_points']] = last_ranking.total_points.median()

  return result

# Executar função para apuração do ranking
df_results = get_ranking(df_results)
display(df_results)

"""## Preparação para o Modelo

Remover dados já apurados e que não vão ajudar na apuração pelo contexto da Copa do Mundo, todos os jogos serão no Quatar
"""

# Remover as colunas usadas para tratamento de dados
df_results = df_results.drop(columns=[
      'date', 
      'datetime', 
      'city', 
      'neutral'
    ])

"""### Visualização de dados preparados"""

# Visualizar os dados alinhados para predição
df_results.head()

df_results.info()

"""### Salvar arquivos preparados"""

# Salvar dados tratados para arquivo
df_results.to_csv('historical_ready.csv')

#from google.colab import files
#files.download('historical_ready.csv')

"""---

## Aplicação do tratamento para as partidas agendadas
"""

df_schedule = pd.read_csv(path_source + 'matches-schedule.csv')

# Renomear colunas para padronização dos campos
df_schedule = df_schedule.rename(columns={'country1': 'home_team', 'country2': 'away_team'})

# Converter texto para date em pandas
df_schedule['datetime'] = pd.to_datetime(df_schedule.date, format='%d/%m/%Y')

# Adicionar dados do torneio e país para todos os jogos agendados
df_schedule['tournament'] = 'FIFA World Cup'
df_schedule['country'] = 'Qatar'

# Renomear os valores na coluna para predição
df_schedule.home_team = df_schedule.home_team.replace({'USA': 'United States'})
df_schedule.away_team = df_schedule.away_team.replace({'USA': 'United States'})

# Aplicação das funções de enriquecimento
get_dates(df_schedule)
df_schedule = get_country_summary(df_schedule)
df_schedule = get_ratios(df_schedule)
df_schedule = get_count_shootouts(df_schedule)
df_schedule = get_ranking(df_schedule)

# Remover campos de orientação
df_schedule = df_schedule.drop(columns=['match', 'phase', 'date', 'datetime'])

# Tem nulo?
print(df_schedule.isnull().values.any())

# Salvar dados tratados para arquivo
df_schedule.to_csv('schedule_ready.csv')

#from google.colab import files
#files.download('schedule_ready.csv')

df_schedule.head()

df_schedule.info()

"""---

## Geração de pré-processadores
"""

# Importação de ferramentas 
from sklearn.compose import ColumnTransformer
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import OneHotEncoder
from sklearn.pipeline import Pipeline

# Listagem de campos numéricos
numeric_features = [
      'weekofyear',
      'month',
      'year',

      'home_games', 
      'home_wins', 
      'home_looses', 
      'home_draws',
      'home_ratio_win_shootouts',   
      'home_median_score',
      'home_ratio_win',
      'home_ratio_win_fifa',
      'home_median_fifa_score',      
      'home_last_rank',
      'home_last_points',      

      'away_games', 
      'away_wins', 
      'away_looses', 
      'away_draws',
      'away_ratio_win_shootouts',
      'away_ratio_win',      
      'away_ratio_win_fifa',
      'away_median_score',
      'away_median_fifa_score',
      'away_last_rank',
      'away_last_points',

      'summary_ratio_win',
      'summary_ratio_win_fifa',
      'summary_median_score',
      'summary_median_fifa_score'
    ]
# Transformação para valores numéricos
numeric_transformer = Pipeline(steps=[
      ("imputer", SimpleImputer(strategy="median")), 
      ("scaler", StandardScaler())
    ])

# Listagem de campo categóricos (texto)
categorical_features = [
      'home_team',
      'home_confederation',
      'away_team',
      'away_confederation',
      'tournament',
      'country',
      'dayofweek'
  ]
# Transformação para valores categóricos
categorical_transformer = OneHotEncoder(handle_unknown="ignore")

# Geração do preprocessador de transformação
preprocessor = ColumnTransformer(transformers=[
      ("num", numeric_transformer, numeric_features),
      ("cat", categorical_transformer, categorical_features),
    ])

"""### Segregação das fontes de dados

Primeiro para classificação e atributos

Posteriormente segregação entre base de treino e teste 
"""

# Biblioteca de Separação de Treino/Teste
from sklearn.model_selection import train_test_split

# Separação de atributos e classficadores
dataset_x = df_results.drop(['home_score', 'away_score'], axis=1)
dataset_y = df_results[['home_score', 'away_score']]

# Separação da amostra de treino e de testes 
train_x, test_x, train_y, test_y = train_test_split(dataset_x, dataset_y, test_size=0.3, random_state=42)
'''
# Critério de Copa do Mundo de 2018
games_fifa_worldcup_2018 = (df_results.year == 2018) & (df_results.tournament == 'FIFA World Cup')

# Separação de atributos com critério de Copa do Mundo de 2018
train_x = df_results[~games_fifa_worldcup_2018].drop(['home_score', 'away_score'], axis=1)
test_x = df_results[games_fifa_worldcup_2018].drop(['home_score', 'away_score'], axis=1)

# Separação de classficadores com critério de Copa do Mundo de 2018
train_y = df_results[~games_fifa_worldcup_2018][['home_score', 'away_score']]
test_y = df_results[games_fifa_worldcup_2018][['home_score', 'away_score']]
'''

"""## Modelagem e Apuração das Predições"""

'''
# Importação do modelo para apreendizado
from sklearn.multioutput import MultiOutputClassifier 
from sklearn.tree import DecisionTreeClassifier

# Inicialização do modelo com a parametrização
cdt = DecisionTreeClassifier(random_state=42)
multicdt = MultiOutputClassifier(cdt)

# Geração do pipeline de previsão
classifierDecisionTree = Pipeline(steps=[("preprocessor", preprocessor), ("classifier", multicdt)])

# Treinamento do modelo
classifierDecisionTree.fit(train_x, train_y)

# Pontuação para Decision Tree Classifier
print("Decision Tree Classifier - score: %.3f" % classifierDecisionTree.score(test_x, test_y))
'''

'''
# Importação do modelo para apreendizado e controlador de várias saídas
from sklearn.multioutput import MultiOutputClassifier 
from sklearn.ensemble import RandomForestClassifier

# Inicialização do modelo com a parametrização
rforest = RandomForestClassifier(random_state=42)
multiRforest = MultiOutputClassifier(rforest)

# Geração do pipeline de previsão
classifierForest = Pipeline(steps=[("preprocessor", preprocessor), ("classifier", multiRforest)])

# Treinamento do modelo
classifierForest.fit(train_x, train_y)

# Pontuação para Random Forest
print("Random Forest - score: %.3f" % classifierForest.score(test_x, test_y))
'''

# Importação do modelo para apreendizado e controlador de várias saídas
from sklearn.multioutput import MultiOutputClassifier 
from sklearn.ensemble import GradientBoostingClassifier

# Inicialização do modelo com a parametrização
gbc = GradientBoostingClassifier(random_state=42)
multiOutputGbc = MultiOutputClassifier(gbc)

# Geração do Pipeline de previsão
classifierGBC = Pipeline(steps=[("preprocessor", preprocessor), ("classifier", multiOutputGbc)])

# Predição e pontuação para Gradient Boosting Classifier 
classifierGBC.fit(train_x, train_y)
print("Gradient Boosting Classifier - score: %.3f" % classifierGBC.score(test_x, test_y))

"""### Tunando o Gradient Boosting Classifier"""

'''
from sklearn.model_selection import GridSearchCV
from sklearn.multioutput import MultiOutputClassifier 
from sklearn.ensemble import GradientBoostingClassifier

param_distributions = {
    "classifier__estimator__n_estimators": [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000],
    "classifier__estimator__max_leaf_nodes": [2, 5, 10, 20, 50, 100],
    "classifier__estimator__learning_rate": [0.01, 0.1, 1],
    "classifier__estimator__max_depth": [3, 4, 5]
  }

# Geração do pipeline 
pipe_gbc = Pipeline(steps=[
    ("preprocessor", preprocessor),
    ("classifier", MultiOutputClassifier(GradientBoostingClassifier(random_state=42)))
  ])

# Gerar grade para busca dos parâmetros
gs_gbc = GridSearchCV(estimator=pipe_gbc, param_grid=param_distributions)

# Treinar os modelos para busca
gs_gbc.fit(train_x, train_y)

# Visualizar os resultados 
print(gs_gbc.best_estimator_)
'''

df_schedule_ready = pd.read_csv('schedule_ready.csv')
df_schedule_ready.dtypes

# Importação do modelo para apreendizado e controlador de várias saídas
from sklearn.multioutput import MultiOutputClassifier
from sklearn.ensemble import GradientBoostingClassifier

# Inicialização do modelo com a parametrização
gbc = GradientBoostingClassifier(random_state=42)
multiOutputGbc = MultiOutputClassifier(gbc)

# Geração do Pipeline de previsão
classifierGBC = Pipeline(steps=[("preprocessor", preprocessor), ("classifier", multiOutputGbc)])

# Treinar o Gradient Boosting Classifier 
classifierGBC.fit(dataset_x, dataset_y)

# Carregar a fonte de dados preparada
df_schedule_ready = pd.read_csv('schedule_ready.csv')
df_schedule_ready.dayofweek = df_schedule_ready.dayofweek.astype(str)
df_schedule_ready[['home_score', 'away_score']] = classifierGBC.predict(df_schedule_ready)

# Remover e renomear colunas para salvar resultado
df_schedule_ready = df_schedule_ready.drop(columns=numeric_features)
df_schedule_ready = df_schedule_ready.drop(columns=['Unnamed: 0', 'tournament', 'country', 'dayofweek', 'home_confederation', 'away_confederation' ])
df_schedule_ready = df_schedule_ready.rename(columns={'home_team': 'home', 'away_team': 'away'})

# Renomear os valores na coluna para predição
df_schedule_ready.home = df_schedule_ready.home.replace({'United States': 'USA'})
df_schedule_ready.away = df_schedule_ready.away.replace({'United States': 'USA'})

# Geração do resultado da previsão
df_schedule_ready.to_csv('result.csv', index=False)

# Download file with game results
#from google.colab import files
#files.download('result.csv')

"""## Referências

[Daryl Felix - Football WorldCup Predictive Model](https://resquatordaryl.medium.com/football-worldcup-predictive-model-9a313ebd28b7)

[Prediction of the FIFA World Cup 2018](https://arxiv.org/pdf/1806.03208v3.pdf)

[Nick Hotz - What is CRISP DM?](https://www.datascience-pm.com/crisp-dm-2/)

[Scikit-learn - Multiclass and multioutput algorithms](https://scikit-learn.org/stable/modules/multiclass.html#multiclass-multioutput-classification)
"""